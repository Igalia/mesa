
template = """\
/* 
 * Copyright (c) 2019 Valve Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * This file was generated by aco_builder_h.py
 */

#ifndef _ACO_BUILDER_
#define _ACO_BUILDER_

#include "aco_ir.h"

namespace aco {
enum dpp_ctrl {
    _dpp_quad_perm = 0x000,
    _dpp_row_sl = 0x100,
    _dpp_row_sr = 0x110,
    _dpp_row_rr = 0x120,
    dpp_wf_sl1 = 0x130,
    dpp_wf_rl1 = 0x134,
    dpp_wf_sr1 = 0x138,
    dpp_wf_rr1 = 0x13C,
    dpp_row_mirror = 0x140,
    dpp_row_half_mirror = 0x141,
    dpp_row_bcast15 = 0x142,
    dpp_row_bcast31 = 0x143
};

inline dpp_ctrl
dpp_quad_perm(unsigned lane0, unsigned lane1, unsigned lane2, unsigned lane3)
{
    assert(lane0 < 4 && lane1 < 4 && lane2 < 4 && lane3 < 4);
    return (dpp_ctrl)(lane0 | (lane1 << 2) | (lane2 << 4) | (lane3 << 6));
}

inline dpp_ctrl
dpp_row_sl(unsigned amount)
{
    assert(amount > 0 && amount < 16);
    return (dpp_ctrl)(((unsigned) _dpp_row_sl) | amount);
}

inline dpp_ctrl
dpp_row_sr(unsigned amount)
{
    assert(amount > 0 && amount < 16);
    return (dpp_ctrl)(((unsigned) _dpp_row_sr) | amount);
}

aco_ptr<Instruction> create_s_mov(Definition dst, Operand src);

class Builder {
public:
   struct Result {
      Instruction *instr;

      Result(Instruction *instr) : instr(instr) {}

      operator Instruction *() const {
         return instr;
      }

      operator Temp() const {
         return instr->getDefinition(0).getTemp();
      }

      operator Operand() const {
         return Operand((Temp)*this);
      }

      Definition& def(unsigned index) const {
         return instr->getDefinition(index);
      }
   };

   struct Op {
      Operand op;
      Op(Temp tmp) : op(tmp) {}
      Op(Operand op_) : op(op_) {}
      Op(Result res) : op((Temp)res) {}
   };

   Program *program;
   bool use_iterator;
   union {
   bool forwards; //when use_iterator == true
   bool start; //when use_iterator == false
   };
   std::vector<aco_ptr<Instruction>> *instructions;
   std::vector<aco_ptr<Instruction>>::iterator it;

   Builder(Program *pgm) : program(pgm), use_iterator(false), start(false), instructions(NULL) {}
   Builder(Program *pgm, Block *block) : program(pgm), use_iterator(false), start(false), instructions(&block->instructions) {}
   Builder(Program *pgm, std::vector<aco_ptr<Instruction>> *instrs) : program(pgm), use_iterator(false), start(false), instructions(instrs) {}

   void moveEnd(Block *block) {
      instructions = &block->instructions;
   }

   void reset() {
      use_iterator = false;
      start = false;
      instructions = NULL;
   }

   Result insert(aco_ptr<Instruction> instr) {
      Instruction *instr_ptr = instr.get();
      if (instructions) {
         if (use_iterator) {
            it = instructions->emplace(it, std::move(instr));
            if (forwards)
               it = std::next(it);
         } else if (!start) {
            instructions->emplace_back(std::move(instr));
         } else {
            instructions->emplace(instructions->begin(), std::move(instr));
         }
      }
      return Result(instr_ptr);
   }

   Result insert(Instruction* instr) {
      if (instructions) {
         if (use_iterator) {
            it = instructions->emplace(it, aco_ptr<Instruction>(instr));
            if (forwards)
               it = std::next(it);
         } else if (!start) {
            instructions->emplace_back(aco_ptr<Instruction>(instr));
         } else {
            instructions->emplace(instructions->begin(), aco_ptr<Instruction>(instr));
         }
      }
      return Result(instr);
   }

   Temp tmp(RegClass rc) {
      return (Temp){program->allocateId(), rc};
   }

   Temp tmp(RegType type, unsigned size) {
      return (Temp){program->allocateId(), getRegClass(type, size)};
   }

   Definition def(RegClass rc) {
      return Definition((Temp){program->allocateId(), rc});
   }

   Definition def(RegType type, unsigned size) {
      return Definition((Temp){program->allocateId(), getRegClass(type, size)});
   }

   Definition def(RegClass rc, PhysReg reg) {
      return Definition(program->allocateId(), reg, rc);
   }

% for fixed in ['m0', 'vcc', 'exec', 'scc']:
   Operand ${fixed}(Temp tmp) {
       Operand op(tmp);
       op.setFixed(aco::${fixed});
       return op;
   }

   Definition ${fixed}(Definition def) {
       def.setFixed(aco::${fixed});
       return def;
   }

% endfor
   /* hand-written helpers */
   Temp as_uniform(Op op)
   {
      assert(op.op.isTemp());
      if (op.op.getTemp().type() == vgpr)
         return pseudo(aco_opcode::p_as_uniform, def(getRegClass(sgpr, op.op.size())), op);
      else
         return op.op.getTemp();
   }
<%
import itertools
formats = [("pseudo", [Format.PSEUDO], 'Instruction', itertools.product(range(5), range(5))),
           ("sop1", [Format.SOP1], 'SOP1_instruction', itertools.product([1, 2], [1])),
           ("sop2", [Format.SOP2], 'SOP2_instruction', itertools.product([1, 2], [2, 3])),
           ("sopk", [Format.SOPK], 'SOPK_instruction', itertools.product([0, 1, 2], [0, 1])),
           ("sopp", [Format.SOPP], 'SOPP_instruction', [(0, 0)]),
           ("sopc", [Format.SOPC], 'SOPC_instruction', [(1, 2)]),
           ("smem", [Format.SMEM], 'SMEM_instruction', [(0, 4), (0, 3), (1, 3), (1, 2)]),
           ("ds", [Format.DS], 'DS_instruction', [(1, 2), (0, 3), (0, 4)]),
           ("mubuf", [Format.MUBUF], 'MUBUF_instruction', [(0, 4), (1, 3)]),
           ("mimg", [Format.MIMG], 'MIMG_instruction', [(0, 4), (1, 3), (0, 3), (1, 2)]), #TODO(pendingchaos): less shapes?
           ("exp", [Format.EXP], 'Export_instruction', [(0, 4)]),
           ("branch", [Format.PSEUDO_BRANCH], 'Pseudo_branch_instruction', itertools.product([0], [0, 1])),
           ("barrier", [Format.PSEUDO_BARRIER], 'Pseudo_barrier_instruction', [(0, 0)]),
           ("reduction", [Format.PSEUDO_REDUCTION], 'Pseudo_reduction_instruction', [(3, 2)]),
           ("vop1", [Format.VOP1], 'VOP1_instruction', [(1, 1)]),
           ("vop2", [Format.VOP2], 'VOP2_instruction', itertools.product([1, 2], [2, 3])),
           ("vopc", [Format.VOPC], 'VOPC_instruction', itertools.product([1, 2], [2])),
           ("vop3", [Format.VOP3A], 'VOP3A_instruction', [(1, 3), (1, 2)]),
           ("vintrp", [Format.VINTRP], 'Interp_instruction', [(1, 2), (1, 3)]),
           ("vop1_dpp", [Format.VOP1, Format.DPP], 'DPP_instruction', [(1, 1)]),
           ("vop2_dpp", [Format.VOP2, Format.DPP], 'DPP_instruction', itertools.product([1, 2], [2, 3])),
           ("vopc_dpp", [Format.VOPC, Format.DPP], 'DPP_instruction', itertools.product([1, 2], [2])),
           ("vop1_e64", [Format.VOP1, Format.VOP3A], 'VOP3A_instruction', itertools.product([1], [1])),
           ("vop2_e64", [Format.VOP2, Format.VOP3A], 'VOP3A_instruction', itertools.product([1, 2], [2, 3])),
           ("vopc_e64", [Format.VOPC, Format.VOP3A], 'VOP3A_instruction', itertools.product([1, 2], [2]))]
%>\\
% for name, formats, struct, shapes in formats:
    % for num_definitions, num_operands in shapes:
        <%
        args = ['aco_opcode opcode']
        for i in range(num_definitions):
            args.append('Definition def%d' % i)
        for i in range(num_operands):
            args.append('Op op%d' % i)
        for f in formats:
            args += f.get_builder_field_decls()
        %>\\

   Result ${name}(${', '.join(args)})
   {
      ${struct} *instr = create_instruction<${struct}>(opcode, (Format)(${'|'.join('(int)Format::%s' % f.name for f in formats)}), ${num_operands}, ${num_definitions});
        % for i in range(num_definitions):
      instr->getDefinition(${i}) = def${i};
        % endfor
        % for i in range(num_operands):
      instr->getOperand(${i}) = op${i}.op;
        % endfor
        % for f in formats:
            % for dest, field_name in zip(f.get_builder_field_dests(), f.get_builder_field_names()):
      instr->${dest} = ${field_name};
            % endfor
        % endfor
      return insert(instr);
   }
    % endfor
% endfor
};

}
#endif /* _ACO_BUILDER_ */"""

from aco_opcodes import opcodes, Format
from mako.template import Template

print(Template(template).render(opcodes=opcodes, Format=Format))
